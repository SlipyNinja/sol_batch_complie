Traceback (most recent call last):
  File "/Users/longfeichen/研究生/Web3MLM/testing/sol_batch_compile-main/batchCompile.py", line 161, in multi_process_directory
    compiled_sol = compile_contract(path, version, filename, copy.deepcopy(settings))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/longfeichen/研究生/Web3MLM/testing/sol_batch_compile-main/batchCompile.py", line 115, in compile_contract
    compiled_sol = compile_standard(setting, allow_paths=path, solc_version=version)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/longfeichen/.env/compile_solidity/lib/python3.12/site-packages/solcx/main.py", line 369, in compile_standard
    raise SolcError(
solcx.exceptions.SolcError: YulException: Variable var_amount_1183 is 10 slot(s) too deep inside the stack.


> command: `/Users/longfeichen/.solcx/solc-v0.8.10 --standard-json --allow-paths /Users/longfeichen/研究生/Web3MLM/testing/sol_batch_compile-main/contracts/0xc0714c331e78d43917fa5364f2f428bcd6953e9e`
> return code: `0`
> stdout:
{"contracts":{"01_01_StakingPlatform.sol":{"Address":{"abi":[],"devdoc":{"details":"Collection of functions related to the address type","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Collection of functions related to the address type\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"01_01_StakingPlatform.sol\":\"Address\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"01_01_StakingPlatform.sol\":{\"keccak256\":\"0xeafc156daf6160310ce7cdbf28239d499193fa4e1b22778ddfb2eaea772fdd2e\",\"urls\":[\"bzz-raw://c1c7d7881c8828ceb8bfc0d97608e03fdd3c6dd89378a485b66004c15640d38f\",\"dweb:/ipfs/Qma2UZ3XfuBfCZoxKfuGErFhtHi785YMnnxVUogUbBWrAE\"]}},\"version\":1}","userdoc":{"kind":"user","methods":{},"version":1}},"Context":{"abi":[],"devdoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"01_01_StakingPlatform.sol\":\"Context\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"01_01_StakingPlatform.sol\":{\"keccak256\":\"0xeafc156daf6160310ce7cdbf28239d499193fa4e1b22778ddfb2eaea772fdd2e\",\"urls\":[\"bzz-raw://c1c7d7881c8828ceb8bfc0d97608e03fdd3c6dd89378a485b66004c15640d38f\",\"dweb:/ipfs/Qma2UZ3XfuBfCZoxKfuGErFhtHi785YMnnxVUogUbBWrAE\"]}},\"version\":1}","userdoc":{"kind":"user","methods":{},"version":1}},"IERC20":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"details":"Interface of the ERC20 standard as defined in the EIP.","events":{"Approval(address,address,uint256)":{"details":"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{"details":"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},"kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{"details":"Returns the amount of tokens owned by `account`."},"totalSupply()":{"details":"Returns the amount of tokens in existence."},"transfer(address,uint256)":{"details":"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{"details":"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC20 standard as defined in the EIP.\",\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"}},\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the amount of tokens owned by `account`.\"},\"totalSupply()\":{\"details\":\"Returns the amount of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"01_01_StakingPlatform.sol\":\"IERC20\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"01_01_StakingPlatform.sol\":{\"keccak256\":\"0xeafc156daf6160310ce7cdbf28239d499193fa4e1b22778ddfb2eaea772fdd2e\",\"urls\":[\"bzz-raw://c1c7d7881c8828ceb8bfc0d97608e03fdd3c6dd89378a485b66004c15640d38f\",\"dweb:/ipfs/Qma2UZ3XfuBfCZoxKfuGErFhtHi785YMnnxVUogUbBWrAE\"]}},\"version\":1}","userdoc":{"kind":"user","methods":{},"version":1}},"IERC20Permit":{"abi":[{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"details":"Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in https://eips.ethereum.org/EIPS/eip-2612[EIP-2612]. Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't need to send a transaction, and thus is not required to hold Ether at all.","kind":"dev","methods":{"DOMAIN_SEPARATOR()":{"details":"Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}."},"nonces(address)":{"details":"Returns the current nonce for `owner`. This value must be included whenever a signature is generated for {permit}. Every successful call to {permit} increases ``owner``'s nonce by one. This prevents a signature from being used multiple times."},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{"details":"Sets `value` as the allowance of `spender` over ``owner``'s tokens, given ``owner``'s signed approval. IMPORTANT: The same issues {IERC20-approve} has related to transaction ordering also apply here. Emits an {Approval} event. Requirements: - `spender` cannot be the zero address. - `deadline` must be a timestamp in the future. - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner` over the EIP712-formatted function arguments. - the signature must use ``owner``'s current nonce (see {nonces}). For more information on the signature format, see the https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section]."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in https://eips.ethereum.org/EIPS/eip-2612[EIP-2612]. Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't need to send a transaction, and thus is not required to hold Ether at all.\",\"kind\":\"dev\",\"methods\":{\"DOMAIN_SEPARATOR()\":{\"details\":\"Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\"},\"nonces(address)\":{\"details\":\"Returns the current nonce for `owner`. This value must be included whenever a signature is generated for {permit}. Every successful call to {permit} increases ``owner``'s nonce by one. This prevents a signature from being used multiple times.\"},\"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\":{\"details\":\"Sets `value` as the allowance of `spender` over ``owner``'s tokens, given ``owner``'s signed approval. IMPORTANT: The same issues {IERC20-approve} has related to transaction ordering also apply here. Emits an {Approval} event. Requirements: - `spender` cannot be the zero address. - `deadline` must be a timestamp in the future. - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner` over the EIP712-formatted function arguments. - the signature must use ``owner``'s current nonce (see {nonces}). For more information on the signature format, see the https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section].\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"01_01_StakingPlatform.sol\":\"IERC20Permit\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"01_01_StakingPlatform.sol\":{\"keccak256\":\"0xeafc156daf6160310ce7cdbf28239d499193fa4e1b22778ddfb2eaea772fdd2e\",\"urls\":[\"bzz-raw://c1c7d7881c8828ceb8bfc0d97608e03fdd3c6dd89378a485b66004c15640d38f\",\"dweb:/ipfs/Qma2UZ3XfuBfCZoxKfuGErFhtHi785YMnnxVUogUbBWrAE\"]}},\"version\":1}","userdoc":{"kind":"user","methods":{},"version":1}},"IStakingPlatform":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"stakeHolder","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Claim","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"startPeriod","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"lockupPeriod","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"endingPeriod","type":"uint256"}],"name":"StartStaking","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Withdraw","type":"event"},{"inputs":[{"internalType":"address","name":"stakeHolder","type":"address"}],"name":"amountStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"claimRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"deposit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"stakeHolder","type":"address"}],"name":"rewardOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"startStaking","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"totalDeposited","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"withdrawAll","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"author":"RetreebInc","events":{"Claim(address,uint256)":{"details":"Emitted when `stakeHolder` claim rewards"},"Deposit(address,uint256)":{"details":"Emitted when `amount` tokens are deposited into staking platform"},"StartStaking(uint256,uint256,uint256)":{"details":"Emitted when staking has started"},"Withdraw(address,uint256)":{"details":"Emitted when user withdraw deposited `amount`"}},"kind":"dev","methods":{"amountStaked(address)":{"params":{"stakeHolder":", address of the user to check"},"returns":{"_0":"uint amount of the total deposited Tokens by the caller"}},"claimRewards()":{"details":"transfer the pending rewards to the `msg.sender`"},"deposit(uint256)":{"details":"user must first approve the amount to deposit before calling this function, cannot exceed the `maxAmountStaked``endPeriod` to equal 0 (Staking didn't started yet), or `endPeriod` more than current `block.timestamp` (staking not finished yet)`totalStaked + amount` must be less than `stakingMax`that the amount deposited should greater than 0","params":{"amount":", the amount to be deposited"}},"rewardOf(address)":{"params":{"stakeHolder":", address of the user to be checked"},"returns":{"_0":"uint amount of claimable rewards"}},"startStaking()":{"details":"set `startPeriod` to the current current `block.timestamp` set `lockupPeriod` which is `block.timestamp` + `lockupDuration` and `endPeriod` which is `startPeriod` + `stakingDuration`"},"totalDeposited()":{"returns":{"_0":"uint amount of the total deposited Tokens"}},"withdraw(uint256)":{"details":"`block.timestamp` must be higher than `lockupPeriod` (lockupPeriod finished)`amount` must be higher than `0``amount` must be lower or equal to the amount staked withdraw reset all states variable for the `msg.sender` to 0, and claim rewards if rewards to claim","params":{"amount":", amount to withdraw"}},"withdrawAll()":{"details":"must be called only when `block.timestamp` >= `endPeriod``block.timestamp` higher than `lockupPeriod` (lockupPeriod finished) withdraw reset all states variable for the `msg.sender` to 0, and claim rewards if rewards to claim"}},"title":"Interface Staking Platform with fixed APY and lockup","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeHolder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockupPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endingPeriod\",\"type\":\"uint256\"}],\"name\":\"StartStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeHolder\",\"type\":\"address\"}],\"name\":\"amountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeHolder\",\"type\":\"address\"}],\"name\":\"rewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"RetreebInc\",\"events\":{\"Claim(address,uint256)\":{\"details\":\"Emitted when `stakeHolder` claim rewards\"},\"Deposit(address,uint256)\":{\"details\":\"Emitted when `amount` tokens are deposited into staking platform\"},\"StartStaking(uint256,uint256,uint256)\":{\"details\":\"Emitted when staking has started\"},\"Withdraw(address,uint256)\":{\"details\":\"Emitted when user withdraw deposited `amount`\"}},\"kind\":\"dev\",\"methods\":{\"amountStaked(address)\":{\"params\":{\"stakeHolder\":\", address of the user to check\"},\"returns\":{\"_0\":\"uint amount of the total deposited Tokens by the caller\"}},\"claimRewards()\":{\"details\":\"transfer the pending rewards to the `msg.sender`\"},\"deposit(uint256)\":{\"details\":\"user must first approve the amount to deposit before calling this function, cannot exceed the `maxAmountStaked``endPeriod` to equal 0 (Staking didn't started yet), or `endPeriod` more than current `block.timestamp` (staking not finished yet)`totalStaked + amount` must be less than `stakingMax`that the amount deposited should greater than 0\",\"params\":{\"amount\":\", the amount to be deposited\"}},\"rewardOf(address)\":{\"params\":{\"stakeHolder\":\", address of the user to be checked\"},\"returns\":{\"_0\":\"uint amount of claimable rewards\"}},\"startStaking()\":{\"details\":\"set `startPeriod` to the current current `block.timestamp` set `lockupPeriod` which is `block.timestamp` + `lockupDuration` and `endPeriod` which is `startPeriod` + `stakingDuration`\"},\"totalDeposited()\":{\"returns\":{\"_0\":\"uint amount of the total deposited Tokens\"}},\"withdraw(uint256)\":{\"details\":\"`block.timestamp` must be higher than `lockupPeriod` (lockupPeriod finished)`amount` must be higher than `0``amount` must be lower or equal to the amount staked withdraw reset all states variable for the `msg.sender` to 0, and claim rewards if rewards to claim\",\"params\":{\"amount\":\", amount to withdraw\"}},\"withdrawAll()\":{\"details\":\"must be called only when `block.timestamp` >= `endPeriod``block.timestamp` higher than `lockupPeriod` (lockupPeriod finished) withdraw reset all states variable for the `msg.sender` to 0, and claim rewards if rewards to claim\"}},\"title\":\"Interface Staking Platform with fixed APY and lockup\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"amountStaked(address)\":{\"notice\":\"function that returns the amount of total Staked tokens for a specific user\"},\"claimRewards()\":{\"notice\":\"function that claims pending rewards\"},\"deposit(uint256)\":{\"notice\":\"function that allows a user to deposit tokens\"},\"rewardOf(address)\":{\"notice\":\"function that returns the amount of pending rewards that can be claimed by the user\"},\"startStaking()\":{\"notice\":\"function that start the staking\"},\"totalDeposited()\":{\"notice\":\"function that returns the amount of total Staked tokens on the smart contract\"},\"withdraw(uint256)\":{\"notice\":\"function that allows a user to withdraw its initial deposit\"},\"withdrawAll()\":{\"notice\":\"function that allows a user to withdraw its initial deposit\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"01_01_StakingPlatform.sol\":\"IStakingPlatform\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"01_01_StakingPlatform.sol\":{\"keccak256\":\"0xeafc156daf6160310ce7cdbf28239d499193fa4e1b22778ddfb2eaea772fdd2e\",\"urls\":[\"bzz-raw://c1c7d7881c8828ceb8bfc0d97608e03fdd3c6dd89378a485b66004c15640d38f\",\"dweb:/ipfs/Qma2UZ3XfuBfCZoxKfuGErFhtHi785YMnnxVUogUbBWrAE\"]}},\"version\":1}","userdoc":{"kind":"user","methods":{"amountStaked(address)":{"notice":"function that returns the amount of total Staked tokens for a specific user"},"claimRewards()":{"notice":"function that claims pending rewards"},"deposit(uint256)":{"notice":"function that allows a user to deposit tokens"},"rewardOf(address)":{"notice":"function that returns the amount of pending rewards that can be claimed by the user"},"startStaking()":{"notice":"function that start the staking"},"totalDeposited()":{"notice":"function that returns the amount of total Staked tokens on the smart contract"},"withdraw(uint256)":{"notice":"function that allows a user to withdraw its initial deposit"},"withdrawAll()":{"notice":"function that allows a user to withdraw its initial deposit"}},"version":1}},"Ownable":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"01_01_StakingPlatform.sol\":\"Ownable\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"01_01_StakingPlatform.sol\":{\"keccak256\":\"0xeafc156daf6160310ce7cdbf28239d499193fa4e1b22778ddfb2eaea772fdd2e\",\"urls\":[\"bzz-raw://c1c7d7881c8828ceb8bfc0d97608e03fdd3c6dd89378a485b66004c15640d38f\",\"dweb:/ipfs/Qma2UZ3XfuBfCZoxKfuGErFhtHi785YMnnxVUogUbBWrAE\"]}},\"version\":1}","userdoc":{"kind":"user","methods":{},"version":1}},"SafeERC20":{"abi":[],"devdoc":{"details":"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, which allows you to call the safe operations as `token.safeTransfer(...)`, etc.","kind":"dev","methods":{},"title":"SafeERC20","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\",\"kind\":\"dev\",\"methods\":{},\"title\":\"SafeERC20\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"01_01_StakingPlatform.sol\":\"SafeERC20\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"01_01_StakingPlatform.sol\":{\"keccak256\":\"0xeafc156daf6160310ce7cdbf28239d499193fa4e1b22778ddfb2eaea772fdd2e\",\"urls\":[\"bzz-raw://c1c7d7881c8828ceb8bfc0d97608e03fdd3c6dd89378a485b66004c15640d38f\",\"dweb:/ipfs/Qma2UZ3XfuBfCZoxKfuGErFhtHi785YMnnxVUogUbBWrAE\"]}},\"version\":1}","userdoc":{"kind":"user","methods":{},"version":1}},"StakingPlatform":{"abi":[{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"uint256","name":"_fixedAPY","type":"uint256"},{"internalType":"uint256","name":"_durationInDays","type":"uint256"},{"internalType":"uint256","name":"_lockDurationInDays","type":"uint256"},{"internalType":"uint256","name":"_maxAmountStaked","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"stakeHolder","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Claim","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"startPeriod","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"lockupPeriod","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"endingPeriod","type":"uint256"}],"name":"StartStaking","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Withdraw","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"_userStartTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"stakeHolder","type":"address"}],"name":"amountStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"claimRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"deposit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"endPeriod","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"fixedAPY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lockupDuration","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lockupPeriod","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"stakeHolder","type":"address"}],"name":"rewardOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"_newAPY","type":"uint8"}],"name":"setAPY","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"staked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"stakingDuration","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"stakingMax","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"startPeriod","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"startStaking","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalDeposited","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"withdrawAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"withdrawResidualBalance","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"author":"www.github.com/jscrui","kind":"dev","methods":{"amountStaked(address)":{"params":{"stakeHolder":", address of the user to check"},"returns":{"_0":"uint amount of the total deposited Tokens by the caller"}},"claimRewards()":{"details":"transfer the pending rewards to the `msg.sender`"},"constructor":{"details":"all parameters are immutable","params":{"_fixedAPY":", the fixed APY (in %) 100 = 10%, 500 = 50%","_token":", address of the token to be staked"}},"deposit(uint256)":{"details":"user must first approve the amount to deposit before calling this function, cannot exceed the `maxAmountStaked``endPeriod` to equal 0 (Staking didn't started yet), or `endPeriod` more than current `block.timestamp` (staking not finished yet)`totalStaked + amount` must be less than `stakingMax`that the amount deposited should greater than 0","params":{"amount":", the amount to be deposited"}},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"rewardOf(address)":{"params":{"stakeHolder":", address of the user to be checked"},"returns":{"_0":"uint amount of claimable rewards"}},"setAPY(uint8)":{"params":{"_newAPY":", the new APY to be set (in %) 100 = 10%, 500 = 50"}},"startStaking()":{"details":"set `startPeriod` to the current current `block.timestamp` set `lockupPeriod` which is `block.timestamp` + `lockupDuration` and `endPeriod` which is `startPeriod` + `stakingDuration`"},"totalDeposited()":{"returns":{"_0":"uint amount of the total deposited Tokens"}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"withdraw(uint256)":{"details":"`block.timestamp` must be higher than `lockupPeriod` (lockupPeriod finished)`amount` must be higher than `0``amount` must be lower or equal to the amount staked withdraw reset all states variable for the `msg.sender` to 0, and claim rewards if rewards to claim","params":{"amount":", amount to withdraw"}},"withdrawAll()":{"details":"must be called only when `block.timestamp` >= `lockupPeriod``block.timestamp` higher than `lockupPeriod` (lockupPeriod finished) withdraw reset all states variable for the `msg.sender` to 0, and claim rewards if rewards to claim"},"withdrawResidualBalance()":{"details":"Can only be called after the end of the staking period Cannot claim initial stakeholders deposit"}},"title":"Staking Platform with fixed APY and lockup","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fixedAPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_durationInDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDurationInDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmountStaked\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeHolder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockupPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endingPeriod\",\"type\":\"uint256\"}],\"name\":\"StartStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeHolder\",\"type\":\"address\"}],\"name\":\"amountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeHolder\",\"type\":\"address\"}],\"name\":\"rewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newAPY\",\"type\":\"uint8\"}],\"name\":\"setAPY\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawResidualBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"www.github.com/jscrui\",\"kind\":\"dev\",\"methods\":{\"amountStaked(address)\":{\"params\":{\"stakeHolder\":\", address of the user to check\"},\"returns\":{\"_0\":\"uint amount of the total deposited Tokens by the caller\"}},\"claimRewards()\":{\"details\":\"transfer the pending rewards to the `msg.sender`\"},\"constructor\":{\"details\":\"all parameters are immutable\",\"params\":{\"_fixedAPY\":\", the fixed APY (in %) 100 = 10%, 500 = 50%\",\"_token\":\", address of the token to be staked\"}},\"deposit(uint256)\":{\"details\":\"user must first approve the amount to deposit before calling this function, cannot exceed the `maxAmountStaked``endPeriod` to equal 0 (Staking didn't started yet), or `endPeriod` more than current `block.timestamp` (staking not finished yet)`totalStaked + amount` must be less than `stakingMax`that the amount deposited should greater than 0\",\"params\":{\"amount\":\", the amount to be deposited\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"rewardOf(address)\":{\"params\":{\"stakeHolder\":\", address of the user to be checked\"},\"returns\":{\"_0\":\"uint amount of claimable rewards\"}},\"setAPY(uint8)\":{\"params\":{\"_newAPY\":\", the new APY to be set (in %) 100 = 10%, 500 = 50\"}},\"startStaking()\":{\"details\":\"set `startPeriod` to the current current `block.timestamp` set `lockupPeriod` which is `block.timestamp` + `lockupDuration` and `endPeriod` which is `startPeriod` + `stakingDuration`\"},\"totalDeposited()\":{\"returns\":{\"_0\":\"uint amount of the total deposited Tokens\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"withdraw(uint256)\":{\"details\":\"`block.timestamp` must be higher than `lockupPeriod` (lockupPeriod finished)`amount` must be higher than `0``amount` must be lower or equal to the amount staked withdraw reset all states variable for the `msg.sender` to 0, and claim rewards if rewards to claim\",\"params\":{\"amount\":\", amount to withdraw\"}},\"withdrawAll()\":{\"details\":\"must be called only when `block.timestamp` >= `lockupPeriod``block.timestamp` higher than `lockupPeriod` (lockupPeriod finished) withdraw reset all states variable for the `msg.sender` to 0, and claim rewards if rewards to claim\"},\"withdrawResidualBalance()\":{\"details\":\"Can only be called after the end of the staking period Cannot claim initial stakeholders deposit\"}},\"title\":\"Staking Platform with fixed APY and lockup\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"amountStaked(address)\":{\"notice\":\"function that returns the amount of total Staked tokens for a specific user\"},\"claimRewards()\":{\"notice\":\"function that claims pending rewards\"},\"constructor\":{\"notice\":\"constructor contains all the parameters of the staking platform\"},\"deposit(uint256)\":{\"notice\":\"function that allows a user to deposit tokens\"},\"rewardOf(address)\":{\"notice\":\"function that returns the amount of pending rewards that can be claimed by the user\"},\"setAPY(uint8)\":{\"notice\":\"function that allows the owner to set the APY\"},\"startStaking()\":{\"notice\":\"function that start the staking\"},\"totalDeposited()\":{\"notice\":\"function that returns the amount of total Staked tokens on the smart contract\"},\"withdraw(uint256)\":{\"notice\":\"function that allows a user to withdraw its initial deposit\"},\"withdrawAll()\":{\"notice\":\"function that allows a user to withdraw its initial deposit\"},\"withdrawResidualBalance()\":{\"notice\":\"claim all remaining balance on the contract Residual balance is all the remaining tokens that have not been distributed (e.g, in case the number of stakeholders is not sufficient)\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"01_01_StakingPlatform.sol\":\"StakingPlatform\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"01_01_StakingPlatform.sol\":{\"keccak256\":\"0xeafc156daf6160310ce7cdbf28239d499193fa4e1b22778ddfb2eaea772fdd2e\",\"urls\":[\"bzz-raw://c1c7d7881c8828ceb8bfc0d97608e03fdd3c6dd89378a485b66004c15640d38f\",\"dweb:/ipfs/Qma2UZ3XfuBfCZoxKfuGErFhtHi785YMnnxVUogUbBWrAE\"]}},\"version\":1}","userdoc":{"kind":"user","methods":{"amountStaked(address)":{"notice":"function that returns the amount of total Staked tokens for a specific user"},"claimRewards()":{"notice":"function that claims pending rewards"},"constructor":{"notice":"constructor contains all the parameters of the staking platform"},"deposit(uint256)":{"notice":"function that allows a user to deposit tokens"},"rewardOf(address)":{"notice":"function that returns the amount of pending rewards that can be claimed by the user"},"setAPY(uint8)":{"notice":"function that allows the owner to set the APY"},"startStaking()":{"notice":"function that start the staking"},"totalDeposited()":{"notice":"function that returns the amount of total Staked tokens on the smart contract"},"withdraw(uint256)":{"notice":"function that allows a user to withdraw its initial deposit"},"withdrawAll()":{"notice":"function that allows a user to withdraw its initial deposit"},"withdrawResidualBalance()":{"notice":"claim all remaining balance on the contract Residual balance is all the remaining tokens that have not been distributed (e.g, in case the number of stakeholders is not sufficient)"}},"version":1}}}},"errors":[{"component":"general","formattedMessage":"YulException: Variable var_amount_1183 is 10 slot(s) too deep inside the stack.\n\n","message":"Yul exception:Variable var_amount_1183 is 10 slot(s) too deep inside the stack.","severity":"error","type":"YulException"}],"sources":{"01_01_StakingPlatform.sol":{"id":0}}}

> stderr:
